{"version":3,"names":["findMediaTrackByUid","mediaTracks","uid","find","track","findQualityByUid","mediaTrack","qualities","quality","findQualitiesByUid","Array","isArray","filter","includes","undefined"],"sources":["MediaTrack.ts"],"sourcesContent":["import type { Track } from './Track';\nimport type { Quality } from './Quality';\n\nexport type MediaTrackKind = 'main' | 'alternative';\n\n/**\n * Represents a media track (audio or video) of a media resource.\n *\n * @public\n */\nexport interface MediaTrack extends Track {\n  /**\n   * The identifier of the media track.\n   *\n   * @remarks\n   * <br/> - This identifier can be used to distinguish between related tracks, e.g. tracks in the same list.\n   */\n  // Note: This identifier is a randomly generated string.\n  readonly id: string;\n\n  /**\n   * A unique identifier of the media track.\n   *\n   * @remarks\n   * <br/> - This identifier is unique across tracks of a THEOplayer instance and can be used to distinguish between tracks.\n   * <br/> - This identifier is a randomly generated number.\n   */\n  readonly uid: number;\n\n  /**\n   * The kind of the media track, represented by a value from the following list:\n   * <br/> - `'main'`: The track is the default track for playback\n   * <br/> - `'alternative'`: The track is not the default track for playback\n   */\n  readonly kind: MediaTrackKind;\n\n  /**\n   * The label of the media track.\n   */\n  readonly label: string;\n\n  /**\n   * The language of the media track.\n   */\n  readonly language: string;\n\n  /**\n   * The uid of the active quality of the media track, i.e. the quality that is currently being played.\n   */\n  readonly activeQuality: number | undefined;\n\n  /**\n   * The qualities of the media track.\n   */\n  readonly qualities: Quality[];\n\n  /**\n   * One or more desired uids of qualities of the media track.\n   *\n   * @remarks\n   * <br/> - If desired qualities are present, the Adaptive Bitrate mechanism of the player will limit itself to these qualities.\n   * <br/> - If one desired quality is present, the Adaptive Bitrate mechanism of the player will be disabled and the desired quality will be played back.\n   */\n  readonly targetQuality: number | number[] | undefined;\n}\n\nexport function findMediaTrackByUid(mediaTracks: MediaTrack[], uid: number | undefined): MediaTrack | undefined {\n  return mediaTracks.find((track) => track.uid === uid);\n}\n\nexport function findQualityByUid(mediaTrack: MediaTrack, uid: number | undefined): Quality | undefined {\n  return mediaTrack.qualities.find((quality) => quality.uid === uid);\n}\n\nexport function findQualitiesByUid(mediaTrack: MediaTrack | undefined, uid: number | number[] | undefined): Quality[] | undefined {\n  if (uid && mediaTrack) {\n    if (Array.isArray(uid)) {\n      return mediaTrack.qualities.filter((quality) => uid.includes(quality.uid));\n    } else {\n      const quality = findQualityByUid(mediaTrack, uid);\n      return quality ? [quality] : undefined;\n    }\n  }\n  return undefined;\n}\n"],"mappings":";;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AAyDO,SAASA,mBAAT,CAA6BC,WAA7B,EAAwDC,GAAxD,EAAyG;EAC9G,OAAOD,WAAW,CAACE,IAAZ,CAAkBC,KAAD,IAAWA,KAAK,CAACF,GAAN,KAAcA,GAA1C,CAAP;AACD;;AAEM,SAASG,gBAAT,CAA0BC,UAA1B,EAAkDJ,GAAlD,EAAgG;EACrG,OAAOI,UAAU,CAACC,SAAX,CAAqBJ,IAArB,CAA2BK,OAAD,IAAaA,OAAO,CAACN,GAAR,KAAgBA,GAAvD,CAAP;AACD;;AAEM,SAASO,kBAAT,CAA4BH,UAA5B,EAAgEJ,GAAhE,EAA2H;EAChI,IAAIA,GAAG,IAAII,UAAX,EAAuB;IACrB,IAAII,KAAK,CAACC,OAAN,CAAcT,GAAd,CAAJ,EAAwB;MACtB,OAAOI,UAAU,CAACC,SAAX,CAAqBK,MAArB,CAA6BJ,OAAD,IAAaN,GAAG,CAACW,QAAJ,CAAaL,OAAO,CAACN,GAArB,CAAzC,CAAP;IACD,CAFD,MAEO;MACL,MAAMM,OAAO,GAAGH,gBAAgB,CAACC,UAAD,EAAaJ,GAAb,CAAhC;MACA,OAAOM,OAAO,GAAG,CAACA,OAAD,CAAH,GAAeM,SAA7B;IACD;EACF;;EACD,OAAOA,SAAP;AACD"}